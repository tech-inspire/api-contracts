// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: posts/v1/posts.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Defines the types of image variants.
public enum Posts_V1_VariantType: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case unspecified // = 0

  /// Original full-size image
  case original // = 1

  /// Thumbnail or preview image
  case thumbnail // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .original
    case 2: self = .thumbnail
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .original: return 1
    case .thumbnail: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Posts_V1_VariantType] = [
    .unspecified,
    .original,
    .thumbnail,
  ]

}

/// ImageVariant describes a derived version of a post image, such as an original
/// or thumbnail variant.
public struct Posts_V1_ImageVariant: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// S3 URL of the image variant.
  public var url: String = String()

  /// Width of the image in pixels.
  public var width: Int32 = 0

  /// Height of the image in pixels.
  public var height: Int32 = 0

  /// Size of the image variant in bytes.
  public var size: Int32 = 0

  /// Type of the variant (e.g., ORIG, THUMB). Must be one of the defined variants.
  public var variantType: Posts_V1_VariantType = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Post represents a user-created post with one or more image variants and optional
/// SoundCloud metadata.
public struct Posts_V1_Post: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// UUIDv7 of the post.
  public var postID: String = String()

  /// UUID of the post's author.
  public var authorID: String = String()

  /// List of image variants in order, such as original followed by thumbnails.
  public var images: [Posts_V1_ImageVariant] = []

  /// Optional SoundCloud track identifier.
  public var soundcloudSong: String {
    get {return _soundcloudSong ?? String()}
    set {_soundcloudSong = newValue}
  }
  /// Returns true if `soundcloudSong` has been explicitly set.
  public var hasSoundcloudSong: Bool {return self._soundcloudSong != nil}
  /// Clears the value of `soundcloudSong`. Subsequent reads from it will return its default value.
  public mutating func clearSoundcloudSong() {self._soundcloudSong = nil}

  /// Optional start time for the SoundCloud track in seconds.
  public var soundcloudSongStart: Int32 {
    get {return _soundcloudSongStart ?? 0}
    set {_soundcloudSongStart = newValue}
  }
  /// Returns true if `soundcloudSongStart` has been explicitly set.
  public var hasSoundcloudSongStart: Bool {return self._soundcloudSongStart != nil}
  /// Clears the value of `soundcloudSongStart`. Subsequent reads from it will return its default value.
  public mutating func clearSoundcloudSongStart() {self._soundcloudSongStart = nil}

  /// Text description provided by the author.
  public var description_p: String = String()

  /// Timestamp when the post was created.
  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {self._createdAt = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _soundcloudSong: String? = nil
  fileprivate var _soundcloudSongStart: Int32? = nil
  fileprivate var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// AddPostRequest contains the data required to create a new post, including the
/// upload session key and metadata for the original image.
public struct Posts_V1_AddPostRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Key returned by GetUploadUrl, used to validate the upload.
  public var uploadSessionKey: String = String()

  /// Width of the original image in pixels.
  public var imageWidth: Int32 = 0

  /// Height of the original image in pixels.
  public var imageHeight: Int32 = 0

  /// Size of the original image in bytes.
  public var imageSize: Int32 = 0

  /// Optional SoundCloud track identifier.
  public var soundcloudSong: String {
    get {return _soundcloudSong ?? String()}
    set {_soundcloudSong = newValue}
  }
  /// Returns true if `soundcloudSong` has been explicitly set.
  public var hasSoundcloudSong: Bool {return self._soundcloudSong != nil}
  /// Clears the value of `soundcloudSong`. Subsequent reads from it will return its default value.
  public mutating func clearSoundcloudSong() {self._soundcloudSong = nil}

  /// Optional start time for the SoundCloud track in seconds.
  public var soundcloudSongStart: Int32 {
    get {return _soundcloudSongStart ?? 0}
    set {_soundcloudSongStart = newValue}
  }
  /// Returns true if `soundcloudSongStart` has been explicitly set.
  public var hasSoundcloudSongStart: Bool {return self._soundcloudSongStart != nil}
  /// Clears the value of `soundcloudSongStart`. Subsequent reads from it will return its default value.
  public mutating func clearSoundcloudSongStart() {self._soundcloudSongStart = nil}

  /// Text description for the post.
  public var description_p: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _soundcloudSong: String? = nil
  fileprivate var _soundcloudSongStart: Int32? = nil
}

/// AddPostResponse returns the newly created post object.
public struct Posts_V1_AddPostResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Newly created post object.
  public var post: Posts_V1_Post {
    get {return _post ?? Posts_V1_Post()}
    set {_post = newValue}
  }
  /// Returns true if `post` has been explicitly set.
  public var hasPost: Bool {return self._post != nil}
  /// Clears the value of `post`. Subsequent reads from it will return its default value.
  public mutating func clearPost() {self._post = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _post: Posts_V1_Post? = nil
}

/// GetPostByIDRequest requests a post by its UUID.
public struct Posts_V1_GetPostByIDRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// UUID of the post to retrieve.
  public var postID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// GetPostByIDResponse returns a single post object.
public struct Posts_V1_GetPostByIDResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Requested post object.
  public var post: Posts_V1_Post {
    get {return _post ?? Posts_V1_Post()}
    set {_post = newValue}
  }
  /// Returns true if `post` has been explicitly set.
  public var hasPost: Bool {return self._post != nil}
  /// Clears the value of `post`. Subsequent reads from it will return its default value.
  public mutating func clearPost() {self._post = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _post: Posts_V1_Post? = nil
}

/// GetPostsRequest requests multiple posts by a list of UUIDs.
public struct Posts_V1_GetPostsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// List of UUIDs for the posts to retrieve.
  public var postIds: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// GetPostsResponse returns a list of retrieved post objects.
public struct Posts_V1_GetPostsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// List of retrieved post objects.
  public var posts: [Posts_V1_Post] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// DeletePostRequest requests removal of a post by its UUID.
public struct Posts_V1_DeletePostRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// UUID of the post to delete.
  public var postID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// DeletePostResponse is returned when a post has been deleted successfully.
public struct Posts_V1_DeletePostResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// GetUploadUrlRequest requests a presigned S3 URL for image upload.
public struct Posts_V1_GetUploadUrlRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Expected MIME type of the uploaded file, e.g., "image/jpeg".
  public var mimeType: String = String()

  /// Expected size of the uploaded file in bytes.
  public var fileSize: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// GetUploadUrlResponse returns a presigned URL and session key for S3 uploads.
public struct Posts_V1_GetUploadUrlResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Presigned PUT URL for direct S3 upload.
  public var uploadURL: String = String()

  /// Session key clients must provide when calling AddPost.
  public var uploadSessionKey: String = String()

  public var method: String = String()

  public var headers: Dictionary<String,String> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "posts.v1"

extension Posts_V1_VariantType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "VARIANT_TYPE_UNSPECIFIED"),
    1: .same(proto: "ORIGINAL"),
    2: .same(proto: "THUMBNAIL"),
  ]
}

extension Posts_V1_ImageVariant: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ImageVariant"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "url"),
    2: .same(proto: "width"),
    3: .same(proto: "height"),
    4: .same(proto: "size"),
    5: .standard(proto: "variant_type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.width) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.height) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.size) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.variantType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 1)
    }
    if self.width != 0 {
      try visitor.visitSingularInt32Field(value: self.width, fieldNumber: 2)
    }
    if self.height != 0 {
      try visitor.visitSingularInt32Field(value: self.height, fieldNumber: 3)
    }
    if self.size != 0 {
      try visitor.visitSingularInt32Field(value: self.size, fieldNumber: 4)
    }
    if self.variantType != .unspecified {
      try visitor.visitSingularEnumField(value: self.variantType, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Posts_V1_ImageVariant, rhs: Posts_V1_ImageVariant) -> Bool {
    if lhs.url != rhs.url {return false}
    if lhs.width != rhs.width {return false}
    if lhs.height != rhs.height {return false}
    if lhs.size != rhs.size {return false}
    if lhs.variantType != rhs.variantType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Posts_V1_Post: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Post"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "post_id"),
    2: .standard(proto: "author_id"),
    3: .same(proto: "images"),
    4: .standard(proto: "soundcloud_song"),
    5: .standard(proto: "soundcloud_song_start"),
    6: .same(proto: "description"),
    7: .standard(proto: "created_at"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.postID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.authorID) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.images) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._soundcloudSong) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self._soundcloudSongStart) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._createdAt) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.postID.isEmpty {
      try visitor.visitSingularStringField(value: self.postID, fieldNumber: 1)
    }
    if !self.authorID.isEmpty {
      try visitor.visitSingularStringField(value: self.authorID, fieldNumber: 2)
    }
    if !self.images.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.images, fieldNumber: 3)
    }
    try { if let v = self._soundcloudSong {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._soundcloudSongStart {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 5)
    } }()
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 6)
    }
    try { if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Posts_V1_Post, rhs: Posts_V1_Post) -> Bool {
    if lhs.postID != rhs.postID {return false}
    if lhs.authorID != rhs.authorID {return false}
    if lhs.images != rhs.images {return false}
    if lhs._soundcloudSong != rhs._soundcloudSong {return false}
    if lhs._soundcloudSongStart != rhs._soundcloudSongStart {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Posts_V1_AddPostRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AddPostRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "upload_session_key"),
    4: .standard(proto: "image_width"),
    5: .standard(proto: "image_height"),
    6: .standard(proto: "image_size"),
    7: .standard(proto: "soundcloud_song"),
    8: .standard(proto: "soundcloud_song_start"),
    9: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularStringField(value: &self.uploadSessionKey) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.imageWidth) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.imageHeight) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.imageSize) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self._soundcloudSong) }()
      case 8: try { try decoder.decodeSingularInt32Field(value: &self._soundcloudSongStart) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.uploadSessionKey.isEmpty {
      try visitor.visitSingularStringField(value: self.uploadSessionKey, fieldNumber: 2)
    }
    if self.imageWidth != 0 {
      try visitor.visitSingularInt32Field(value: self.imageWidth, fieldNumber: 4)
    }
    if self.imageHeight != 0 {
      try visitor.visitSingularInt32Field(value: self.imageHeight, fieldNumber: 5)
    }
    if self.imageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.imageSize, fieldNumber: 6)
    }
    try { if let v = self._soundcloudSong {
      try visitor.visitSingularStringField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._soundcloudSongStart {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 8)
    } }()
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Posts_V1_AddPostRequest, rhs: Posts_V1_AddPostRequest) -> Bool {
    if lhs.uploadSessionKey != rhs.uploadSessionKey {return false}
    if lhs.imageWidth != rhs.imageWidth {return false}
    if lhs.imageHeight != rhs.imageHeight {return false}
    if lhs.imageSize != rhs.imageSize {return false}
    if lhs._soundcloudSong != rhs._soundcloudSong {return false}
    if lhs._soundcloudSongStart != rhs._soundcloudSongStart {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Posts_V1_AddPostResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AddPostResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "post"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._post) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._post {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Posts_V1_AddPostResponse, rhs: Posts_V1_AddPostResponse) -> Bool {
    if lhs._post != rhs._post {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Posts_V1_GetPostByIDRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetPostByIDRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "post_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.postID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.postID.isEmpty {
      try visitor.visitSingularStringField(value: self.postID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Posts_V1_GetPostByIDRequest, rhs: Posts_V1_GetPostByIDRequest) -> Bool {
    if lhs.postID != rhs.postID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Posts_V1_GetPostByIDResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetPostByIDResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "post"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._post) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._post {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Posts_V1_GetPostByIDResponse, rhs: Posts_V1_GetPostByIDResponse) -> Bool {
    if lhs._post != rhs._post {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Posts_V1_GetPostsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetPostsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "post_ids"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.postIds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.postIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.postIds, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Posts_V1_GetPostsRequest, rhs: Posts_V1_GetPostsRequest) -> Bool {
    if lhs.postIds != rhs.postIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Posts_V1_GetPostsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetPostsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "posts"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.posts) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.posts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.posts, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Posts_V1_GetPostsResponse, rhs: Posts_V1_GetPostsResponse) -> Bool {
    if lhs.posts != rhs.posts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Posts_V1_DeletePostRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeletePostRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "post_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.postID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.postID.isEmpty {
      try visitor.visitSingularStringField(value: self.postID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Posts_V1_DeletePostRequest, rhs: Posts_V1_DeletePostRequest) -> Bool {
    if lhs.postID != rhs.postID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Posts_V1_DeletePostResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeletePostResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Posts_V1_DeletePostResponse, rhs: Posts_V1_DeletePostResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Posts_V1_GetUploadUrlRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetUploadUrlRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "mime_type"),
    3: .standard(proto: "file_size"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularStringField(value: &self.mimeType) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.fileSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.mimeType.isEmpty {
      try visitor.visitSingularStringField(value: self.mimeType, fieldNumber: 2)
    }
    if self.fileSize != 0 {
      try visitor.visitSingularInt32Field(value: self.fileSize, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Posts_V1_GetUploadUrlRequest, rhs: Posts_V1_GetUploadUrlRequest) -> Bool {
    if lhs.mimeType != rhs.mimeType {return false}
    if lhs.fileSize != rhs.fileSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Posts_V1_GetUploadUrlResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetUploadUrlResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "upload_url"),
    2: .standard(proto: "upload_session_key"),
    3: .same(proto: "method"),
    4: .same(proto: "headers"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.uploadURL) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.uploadSessionKey) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.method) }()
      case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.headers) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.uploadURL.isEmpty {
      try visitor.visitSingularStringField(value: self.uploadURL, fieldNumber: 1)
    }
    if !self.uploadSessionKey.isEmpty {
      try visitor.visitSingularStringField(value: self.uploadSessionKey, fieldNumber: 2)
    }
    if !self.method.isEmpty {
      try visitor.visitSingularStringField(value: self.method, fieldNumber: 3)
    }
    if !self.headers.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.headers, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Posts_V1_GetUploadUrlResponse, rhs: Posts_V1_GetUploadUrlResponse) -> Bool {
    if lhs.uploadURL != rhs.uploadURL {return false}
    if lhs.uploadSessionKey != rhs.uploadSessionKey {return false}
    if lhs.method != rhs.method {return false}
    if lhs.headers != rhs.headers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
